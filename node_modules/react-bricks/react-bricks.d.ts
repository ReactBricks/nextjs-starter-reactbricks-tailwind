import * as React from 'react';
import React__default from 'react';
import { BaseEditor, Editor as Editor$1, Node, Descendant } from 'slate';
import { HistoryEditor } from 'slate-history';
import { ReactEditor, RenderElementProps, RenderLeafProps } from 'slate-react';
import styleInject from '../node_modules/style-inject/dist/style-inject.es.js';
import * as react_query from 'react-query';
import { UseQueryResult } from 'react-query';
export { v4 as uuid } from 'uuid';

declare module 'slate' {
    interface CustomTypes {
        Editor: BaseEditor & ReactEditor & HistoryEditor;
        Element: CustomElement;
        Text: CustomText;
    }
}
/**
 * Props for Text
 */
interface TextProps {
    renderBlock: (props: RenderElementProps) => JSX.Element;
    placeholder: string;
    renderPlaceholder?: (props: {
        children: any;
    }) => JSX.Element;
    propName: string;
    multiline?: boolean;
}
declare const Text: React.FC<TextProps>;

declare namespace types {
    /**
     * Type of Sidebar control
     */
    enum SideEditPropType {
        Text = "TEXT",
        Textarea = "TEXTAREA",
        Number = "NUMBER",
        Date = "DATE",
        Range = "RANGE",
        Boolean = "BOOLEAN",
        Select = "SELECT",
        Image = "IMAGE",
        Custom = "CUSTOM"
    }
    /**
     * How to display the options
     */
    enum OptionsDisplay {
        Select = "SELECT",
        Radio = "RADIO",
        Color = "COLOR"
    }
    /**
     * Features for RichText: see also the new RichTextExt
     */
    enum RichTextFeatures {
        Bold = "BOLD",
        Italic = "ITALIC",
        Code = "CODE",
        Highlight = "HIGHLIGHT",
        Link = "LINK",
        UnorderedList = "UL",
        OrderedList = "OL",
        Heading1 = "H1",
        Heading2 = "H2",
        Heading3 = "H3",
        Heading4 = "H4",
        Heading5 = "H5",
        Heading6 = "H6",
        Quote = "QUOTE"
    }
    /**
     * Page status
     */
    enum PageStatus {
        Draft = "DRAFT",
        Published = "PUBLISHED"
    }
    /**
     * Device type for responsive preview (for the icon)
     */
    enum DeviceType {
        Desktop = "DESKTOP",
        Tablet = "TABLET",
        Phone = "PHONE"
    }
    /**
     * Corner for the click-to-edit button
     */
    enum ClickToEditSide {
        BottomRight = "BOTTOM-RIGHT",
        BottomLeft = "BOTTOM-LEFT",
        TopRight = "TOP-RIGHT",
        TopLeft = "TOP-LEFT"
    }
    /**
     * A Brick is a type of content block
     */
    type Brick<T = {}> = React__default.FC<T> & {
        schema: IBlockType;
    };
    /**
     * Bricks are types of content block
     */
    type Bricks = {
        [key: string]: Brick<any>;
    };
    /**
     * The logged-in User
     */
    type User = {
        id: string;
        email: string;
        firstName: string;
        lastName: string;
        company: string;
        avatarUrl?: string;
        isAdmin: boolean;
        token: string;
        appName: string;
        deployHookUrl?: string;
        deployHookMethod?: string;
        deployHookTriggerOnScheduledPublishing: boolean;
        deployHookStagingUrl?: string;
        deployHookStagingMethod?: string;
        deployHookStagingTriggerOnScheduledPublishing: boolean;
        eventsHookUrl?: string;
        eventsHookAuthToken?: string;
        canCreatePage: boolean;
        canDeletePage: boolean;
        canDeploy: boolean;
        canDeployStaging: boolean;
        role: string;
        plan: string;
        isVerified: boolean;
        languages: Language[];
        defaultLanguage: string;
    } | null;
    /**
     * Translation for a Page
     */
    type Translation = {
        language: string;
        slug: string;
    };
    /**
     * A React Bricks Page
     */
    type Page = {
        id: string;
        type: string;
        name: string;
        slug: string;
        meta: IMeta;
        customValues?: Props;
        externalData?: Props;
        content: IContentBlock[];
        authorId?: string;
        author: Author;
        invalidBlocksTypes?: string[];
        status: PageStatus;
        isLocked: boolean;
        tags: string[];
        createdAt: string;
        publishedAt?: string;
        scheduledForPublishingOn?: string;
        language: string;
        translations: Translation[];
    };
    /**
     * Page fields (without content)
     */
    type PageValues = Omit<Page, 'content'>;
    /**
     * A Page with all optional fields, used for the patch
     */
    type PartialPage = {
        id?: string;
        type?: string;
        name?: string;
        slug?: string;
        meta?: IMeta;
        content?: IContentBlock[];
        authorId?: string;
        author?: Author;
        invalidBlocksTypes?: string[];
        status?: PageStatus;
        isLocked?: boolean;
        tags?: string[];
        createdAt?: string;
        publishedAt?: string;
        language?: string;
        translations?: Translation[];
    };
    /**
     * Page from a list (no content)
     */
    type PageFromList = Omit<Page, 'content'>;
    /**
     * Page from a list with pagination
     */
    type PagesFromListWithPagination = {
        items: PageFromList[];
        pagination: {
            page: number;
            pageSize: number;
            totalItems: number;
            totalPages: number;
        };
    };
    /**
     * The Author of a Page
     */
    type Author = {
        id: string;
        email: string;
        firstName: string;
        lastName: string;
        avatarUrl?: string;
        company?: string;
    };
    /**
     * A Language for i18n
     */
    type Language = {
        code: string;
        name: string;
    };
    /**
     * Render function for local links (should use the app's Router)
     */
    type RenderLocalLink = ({ href, target, className, activeClassName, isAdmin, children, }: {
        href: string;
        target?: string;
        className?: string;
        activeClassName?: string;
        isAdmin?: boolean;
        children: React__default.ReactNode;
    }) => React__default.ReactElement;
    /**
     * Props of a content block
     */
    type Props = {
        [key: string]: any;
    };
    /**
     * Interface for the Schema of a Brick
     */
    interface IBlockType {
        name: string;
        label: string;
        getDefaultProps?: () => object;
        hideFromAddMenu?: boolean;
        sideEditProps?: Array<ISideEditProp | ISideGroup>;
        repeaterItems?: IRepeaterItem[];
        newItemMenuOpen?: boolean;
        mapExternalDataToProps?: (externalData: Props, brickProps?: Props) => Props;
        playgroundLinkUrl?: string;
        playgroundLinkLabel?: string;
        category?: string;
        tags?: string[];
    }
    /**
     * Item of a Repeater
     */
    interface IRepeaterItem {
        name: string;
        itemType: string;
        itemLabel?: string;
        min?: number;
        max?: number;
    }
    /**
     * The content of a block (instance of a Brick)
     */
    interface IContentBlock {
        id: string;
        type: string;
        props: Props;
    }
    /**
     * Option of a select sidebar prop
     */
    interface IOption {
        value: any;
        label: string;
    }
    /**
     * Interface for Props of a Custom sidebar component
     */
    interface ICustomKnobProps {
        id: string;
        value: any;
        onChange: any;
        isValid: boolean;
        errorMessage?: string;
    }
    /**
     * Sidebar edit Props for a Page
     */
    interface ISideEditPropPage {
        name: string;
        label: string;
        type: SideEditPropType;
        component?: React__default.FC<ICustomKnobProps>;
        validate?: (value: any, props?: Props) => boolean | string;
        show?: (props: Props) => boolean;
        textareaOptions?: {
            height?: number;
        };
        imageOptions?: {
            maxWidth: number;
            aspectRatio?: number;
        };
        rangeOptions?: {
            min?: number;
            max?: number;
            step?: number;
        };
        selectOptions?: {
            options?: IOption[];
            getOptions?: () => IOption[] | Promise<IOption[]>;
            display: OptionsDisplay;
        };
    }
    /**
     * Sidebar Edit Props
     */
    interface ISideEditProp extends ISideEditPropPage {
        shouldRefreshText?: boolean;
    }
    /**
     * A collapsible Group of sidebar Props
     */
    interface ISideGroup {
        groupName: string;
        defaultOpen?: boolean;
        show?: (props: Props) => boolean;
        props: ISideEditProp[] | ISideEditPropPage[];
    }
    /**
     * Image value interface
     */
    interface IImageSource {
        src: string;
        placeholderSrc?: string;
        srcSet?: string;
        alt?: string;
        seoName?: string;
        width: number;
        height: number;
    }
    /**
     * File value interface
     */
    interface IFileSource {
        name: string;
        url: string;
        size: number;
    }
    /**
     * A Color for a Select sidebar prop
     */
    interface IColor {
        color: string;
        [propName: string]: any;
    }
    /**
     * Page type
     */
    interface IPageType {
        name: string;
        pluralName: string;
        allowedBlockTypes?: string[];
        excludedBlockTypes?: string[];
        defaultLocked?: boolean;
        defaultStatus?: PageStatus;
        defaultLanguage?: string;
        defaultFeaturedImage?: string;
        getDefaultContent?: () => string[];
        customFields?: Array<ISideEditPropPage | ISideGroup>;
        getExternalData?: (page: Page) => Promise<Props>;
    }
    /**
     * Structure returned by the cleanBlocks function
     */
    interface ICleanBlocks {
        blocks: IContentBlock[];
        invalidBlocksTypes: string[];
    }
    /**
     * Responsive breakpoint for preview
     */
    interface ResponsiveBreakpoint {
        type: DeviceType;
        width: number | string;
        label: string;
    }
    /**
     * The ReactBricks configuration
     */
    interface ReactBricksConfig {
        appId: string;
        apiKey: string;
        bricks?: types.Brick<any>[];
        pageTypes?: types.IPageType[];
        domain?: string;
        title?: string;
        logo?: string;
        icon?: string;
        contentClassName?: string;
        renderLocalLink: types.RenderLocalLink;
        navigate: (path: string) => void;
        loginPath?: string;
        editorPath?: string;
        playgroundPath?: string;
        appSettingsPath?: string;
        isDarkColorMode?: boolean;
        toggleColorMode?: () => void;
        useCssInJs?: boolean;
        appRootElement: string | HTMLElement;
        clickToEditSide?: ClickToEditSide;
        customFields?: Array<ISideEditPropPage | ISideGroup>;
        responsiveBreakpoints?: ResponsiveBreakpoint[];
        enableAutoSave?: boolean;
        disableSaveIfInvalidProps?: boolean;
    }
    /**
     * The ReactBricks context
     */
    interface IReactBricksContext {
        appId: string;
        apiKey: string;
        bricks: Bricks;
        pageTypes: IPageType[];
        domain: string;
        title: string;
        logo: string;
        icon: string;
        contentClassName: string;
        renderLocalLink: RenderLocalLink;
        navigate: (path: string) => void;
        loginPath: string;
        editorPath: string;
        playgroundPath: string;
        appSettingsPath: string;
        isDarkColorMode?: boolean;
        toggleColorMode?: () => void;
        useCssInJs?: boolean;
        appRootElement: string | HTMLElement;
        clickToEditSide?: ClickToEditSide;
        customFields?: Array<ISideEditPropPage | ISideGroup>;
        responsiveBreakpoints: ResponsiveBreakpoint[];
        enableAutoSave: boolean;
        disableSaveIfInvalidProps: boolean;
    }
    /**
     * The Admin context returned from useAdminContext
     */
    interface IReadAdminContext {
        isAdmin: boolean;
        previewMode: boolean;
        currentPage: ICurrentPage;
    }
    /**
     * Meta fields on Page
     */
    interface IMeta {
        title?: string;
        description?: string;
        language?: string;
        featuredImage?: string;
    }
    /**
     * A RichTextExt Plugin
     */
    interface RichTextPlugin {
        type: 'Mark' | 'Block' | 'List';
        name: string;
        isInline?: boolean;
        itemName?: string;
        label: string;
        hotKey?: string;
        renderElement?: (props: RenderElementProps) => JSX.Element;
        renderItemElement?: (props: RenderElementProps) => JSX.Element;
        renderLeaf?: (props: RenderLeafProps) => JSX.Element;
        toggle: (editor: Editor$1, plugins: RichTextPlugin[]) => void;
        button?: {
            icon: React__default.ReactElement;
            isActive: (editor: Editor$1) => boolean;
        };
        enhanceEditor?: (editor: Editor$1) => Editor$1;
    }
    /**
     * Definition for a Mark plugin
     */
    interface MarkPlugin {
        name: string;
        label?: string;
        hotKey?: string;
        render: (props: RenderLeafProps) => JSX.Element;
        icon?: React__default.ReactElement;
    }
    /**
     * Constructor for a Mark plugin
     */
    type MarkPluginConstructor = (markPlugin: MarkPlugin) => RichTextPlugin;
    /**
     * Definition for a Block plugin
     */
    interface BlockPlugin {
        name: string;
        isInline?: boolean;
        itemName?: string;
        label?: string;
        hotKey?: string;
        render: (props: RenderElementProps) => JSX.Element;
        renderItem?: (props: RenderElementProps) => JSX.Element;
        icon?: React__default.ReactElement;
    }
    /**
     * Constructor for a Block plugin
     */
    type BlockPluginConstructor = (blockPlugin: BlockPlugin) => RichTextPlugin;
}

/**
 * Props for RichTextExt (v3)
 */
interface RichTextProps {
    renderBlock: (props: RenderElementProps) => JSX.Element;
    propName: string;
    placeholder: string;
    renderPlaceholder?: (props: {
        children: any;
    }) => JSX.Element;
    plugins?: types.RichTextPlugin[];
    multiline?: boolean;
}
declare const RichText: React.FC<RichTextProps>;

/**
 * Props for renderLink render function
 */
interface RenderLinkElementProps extends RenderElementProps {
    href: string;
}
/**
 * Props for the v2-compatible RichText
 */
interface CompatibleRichTextProps {
    renderBlock: (props: RenderElementProps) => JSX.Element;
    placeholder: string;
    propName: string;
    multiline?: boolean;
    allowedFeatures?: types.RichTextFeatures[];
    renderBold?: (props: RenderLeafProps) => JSX.Element;
    renderItalic?: (props: RenderLeafProps) => JSX.Element;
    renderHighlight?: (props: RenderLeafProps) => JSX.Element;
    renderCode?: (props: RenderLeafProps) => JSX.Element;
    renderLink?: (props: RenderLinkElementProps) => JSX.Element;
    renderUL?: (props: RenderElementProps) => JSX.Element;
    renderOL?: (props: RenderElementProps) => JSX.Element;
    renderLI?: (props: RenderElementProps) => JSX.Element;
    renderH1?: (props: RenderElementProps) => JSX.Element;
    renderH2?: (props: RenderElementProps) => JSX.Element;
    renderH3?: (props: RenderElementProps) => JSX.Element;
    renderH4?: (props: RenderElementProps) => JSX.Element;
    renderH5?: (props: RenderElementProps) => JSX.Element;
    renderH6?: (props: RenderElementProps) => JSX.Element;
    renderQuote?: (props: RenderElementProps) => JSX.Element;
}
declare const CompatibleRichText: React__default.FC<CompatibleRichTextProps>;

/**
 * Props for Image
 */
interface ImageProps {
    propName: string;
    alt: string;
    maxWidth?: number;
    noLazyLoad?: boolean;
    aspectRatio?: number;
    containerClassName?: string;
    containerStyle?: object;
    imageClassName?: string;
    imageStyle?: object;
    noWrapper?: boolean;
}
declare const Image: React.FC<ImageProps>;

/**
 * Props for Text
 */
interface FileProps {
    propName: string;
    renderBlock: (props: types.IFileSource | null) => JSX.Element;
    allowedExtensions?: string[];
}
declare const File: React__default.FC<FileProps>;

/**
 * Props for Repeater
 */
interface RepeaterProps {
    propName: string;
    itemProps?: types.Props;
    renderWrapper?: (items: React.ReactElement) => React.ReactElement;
    renderItemWrapper?: (item: React.ReactElement, index: number, itemsCount: number) => React.ReactElement;
}
declare const Repeater: React.FC<RepeaterProps>;

declare const Link: React.FC<LinkProps>;

declare const useAdminContext: () => types.IReadAdminContext;

declare const useVisualEdit: (propName: string) => [any, (value: any) => void, boolean];

declare const blockPluginConstructor: types.BlockPluginConstructor;

declare const markPluginConstructor: types.MarkPluginConstructor;

declare const ReactBricks: React.FC<types.ReactBricksConfig>;

declare const ReactBricksContext: React.Context<types.IReactBricksContext>;

/**
 * Props for PageViewer
 */
interface PageViewerProps {
    page: types.Page | null | undefined;
}
declare const PageViewer: React.FC<PageViewerProps>;

declare const usePage$1: (pageId: string, language?: string | undefined) => react_query.UseQueryResult<types.Page, unknown>;

declare const usePage: (slug: string, language?: string | undefined) => react_query.UseQueryResult<types.Page, unknown>;

/**
 * Values returned from usePages
 */
interface UsePagesType {
    <T extends boolean>({ type, types, tag, language, page, pageSize, sort, usePagination, }: {
        type?: string;
        types?: string[];
        tag?: string;
        language: string;
        page?: number;
        pageSize?: number;
        sort?: string;
        usePagination: T;
    }): UseQueryResult<T extends true ? types.PagesFromListWithPagination : types.PageFromList[], unknown>;
    ({ type, types, tag, language, page, pageSize, sort, }: {
        type?: string;
        types?: string[];
        language: string;
        tag?: string;
        page?: number;
        pageSize?: number;
        sort?: string;
    }): UseQueryResult<types.PageFromList[], unknown>;
    (): UseQueryResult<types.PageFromList[], unknown>;
}
declare const usePages: UsePagesType;

/**
 * Values returned from the public usePage
 */
interface UsePagesPublicType {
    <T extends boolean>({ type, types, tag, language, page, pageSize, sort, usePagination, }: {
        type?: string;
        types?: string[];
        tag?: string;
        language?: string;
        page?: number;
        pageSize?: number;
        sort?: string;
        usePagination: T;
    }): UseQueryResult<T extends true ? types.PagesFromListWithPagination : types.PageFromList[], unknown>;
    ({ type, types, tag, language, page, pageSize, sort, }: {
        type?: string;
        types?: string[];
        tag?: string;
        language?: string;
        page?: number;
        pageSize?: number;
        sort?: string;
    }): UseQueryResult<types.PageFromList[], unknown>;
    (): UseQueryResult<types.PageFromList[], unknown>;
}
declare const usePagesPublic: UsePagesPublicType;

declare const useTagsPublic: (page?: number, pageSize?: number) => react_query.UseQueryResult<{
    items: string[];
    pagination: {
        page: number;
        pageSize: number;
        totalItems: number;
        totalPages: number;
    };
}, unknown>;

declare const usePageValues: () => [types.PageValues, (pageData: types.PartialPage) => void];

declare const useReactBricksContext: () => types.IReactBricksContext;

declare const fetchPage: (slug: string, apiKey: string, language?: string | undefined, pageTypes?: types.IPageType[] | undefined) => Promise<types.Page>;

/**
 * Values returned from fetchPages
 */
interface FetchPagesType {
    <T extends boolean>(apiKey: string, { type, types, tag, language, page, pageSize, sort, usePagination, }: {
        type?: string;
        types?: string[];
        tag?: string;
        language?: string;
        page?: number;
        pageSize?: number;
        sort?: string;
        usePagination: T;
    }): Promise<T extends true ? types.PagesFromListWithPagination : types.PageFromList[]>;
    (apiKey: string, { type, types, tag, language, page, pageSize, sort, }: {
        type?: string;
        types?: string[];
        tag?: string;
        language?: string;
        page?: number;
        pageSize?: number;
        sort?: string;
    }): Promise<types.PageFromList[]>;
    (apiKey: string): Promise<types.PageFromList[]>;
}
declare const fetchPages: FetchPagesType;

declare const fetchTags: (apiKey: string, page?: number, pageSize?: number) => Promise<{
    items: string[];
    pagination: {
        page: number;
        pageSize: number;
        totalItems: number;
        totalPages: number;
    };
}>;

declare const cleanPage: (page: types.Page, pageTypes: types.IPageType[], bricks: types.Bricks) => types.Page;

declare const getPagePlainText: (blocks: types.IContentBlock[]) => string[];

declare const _default: {
    serialize: (nodes: Node[]) => string;
    deserialize: (input: string) => Descendant[];
    isText: (value: any) => boolean;
};

declare const plugin$d: types.RichTextPlugin;

declare const plugin$c: types.RichTextPlugin;

declare const plugin$b: types.RichTextPlugin;

declare const plugin$a: types.RichTextPlugin;

declare const plugin$9: types.RichTextPlugin;

declare const plugin$8: types.RichTextPlugin;

declare const plugin$7: types.RichTextPlugin;

declare const plugin$6: types.RichTextPlugin;

declare const plugin$5: types.RichTextPlugin;

declare const plugin$4: types.RichTextPlugin;

declare const plugin$3: types.RichTextPlugin;

declare const plugin$2: types.RichTextPlugin;

declare const plugin$1: types.RichTextPlugin;

declare const plugin: types.RichTextPlugin;

declare namespace index {
  export {
    plugin$d as bold,
    plugin$c as italic,
    plugin$b as code,
    plugin$a as highlight,
    plugin$9 as link,
    plugin$8 as heading1,
    plugin$7 as heading2,
    plugin$6 as heading3,
    plugin$5 as heading4,
    plugin$4 as heading5,
    plugin$3 as heading6,
    plugin$2 as quote,
    plugin$1 as orderedList,
    plugin as unorderedList,
  };
}

declare const Editor: React.FC;

declare const Playground: () => JSX.Element;

declare const AppSettings: React.FC;

var css_248z = ".tippy-box[data-animation=fade][data-state=hidden]{opacity:0}[data-tippy-root]{max-width:calc(100vw - 10px)}.tippy-box{background-color:#333;border-radius:4px;color:#fff;font-size:14px;line-height:1.4;outline:0;position:relative;transition-property:transform,visibility,opacity}.tippy-box[data-placement^=top]>.tippy-arrow{bottom:0}.tippy-box[data-placement^=top]>.tippy-arrow:before{border-top-color:initial;border-width:8px 8px 0;bottom:-7px;left:0;transform-origin:center top}.tippy-box[data-placement^=bottom]>.tippy-arrow{top:0}.tippy-box[data-placement^=bottom]>.tippy-arrow:before{border-bottom-color:initial;border-width:0 8px 8px;left:0;top:-7px;transform-origin:center bottom}.tippy-box[data-placement^=left]>.tippy-arrow{right:0}.tippy-box[data-placement^=left]>.tippy-arrow:before{border-left-color:initial;border-width:8px 0 8px 8px;right:-7px;transform-origin:center left}.tippy-box[data-placement^=right]>.tippy-arrow{left:0}.tippy-box[data-placement^=right]>.tippy-arrow:before{border-right-color:initial;border-width:8px 8px 8px 0;left:-7px;transform-origin:center right}.tippy-box[data-inertia][data-state=visible]{transition-timing-function:cubic-bezier(.54,1.5,.38,1.11)}.tippy-arrow{color:#333;height:16px;width:16px}.tippy-arrow:before{border-color:transparent;border-style:solid;content:\"\";position:absolute}.tippy-content{padding:5px 9px;position:relative;z-index:1}";
styleInject(css_248z);

declare const Admin: React.FC<AdminProps>;

declare const AdminContext: React.Context<types.IAdminContext>;

declare const Header: React.FC<HeaderProps>;

declare const Login: React.FC;

declare const useAuth: () => {
    loginUser: (email: string, password: string) => Promise<({
        id: string;
        email: string;
        firstName: string;
        lastName: string;
        company: string;
        avatarUrl?: string | undefined;
        isAdmin: boolean;
        token: string;
        appName: string;
        deployHookUrl?: string | undefined;
        deployHookMethod?: string | undefined;
        deployHookTriggerOnScheduledPublishing: boolean;
        deployHookStagingUrl?: string | undefined;
        deployHookStagingMethod?: string | undefined;
        deployHookStagingTriggerOnScheduledPublishing: boolean;
        eventsHookUrl?: string | undefined;
        eventsHookAuthToken?: string | undefined;
        canCreatePage: boolean;
        canDeletePage: boolean;
        canDeploy: boolean;
        canDeployStaging: boolean;
        role: string;
        plan: string;
        isVerified: boolean;
        languages: types.Language[];
        defaultLanguage: string;
    } & {
        authToken: string;
    }) | null>;
    logoutUser: () => void;
};

export { Admin, AdminContext, AppSettings, Editor, File, Header, Image, Link, Login, PageViewer, _default as Plain, Playground, ReactBricks, ReactBricksContext, Repeater, CompatibleRichText as RichText, RichText as RichTextExt, Text, blockPluginConstructor, cleanPage, fetchPage, fetchPages, fetchTags, getPagePlainText, markPluginConstructor, index as plugins, types, useAdminContext, useAuth, usePage$1 as usePage, usePage as usePagePublic, usePageValues, usePages, usePagesPublic, useReactBricksContext, useTagsPublic, useVisualEdit };
